import { IOCSet } from './ioc-extractor';

export interface ReportFormat {
  id: string;
  name: string;
  description: string;
  fileExtension: string;
  mimeType: string;
  template: string;
  variables: string[];
}

export interface ReportData {
  title: string;
  timestamp: string;
  analyst: string;
  iocs: IOCSet;
  queries: any[];
  ttps: any[];
  detections: any[];
  summary: {
    totalIOCs: number;
    totalQueries: number;
    totalTTPs: number;
    vendors: string[];
  };
}

export const reportFormats: ReportFormat[] = [
  {
    id: 'executive-summary',
    name: 'Executive Summary',
    description: 'High-level threat intelligence summary for leadership',
    fileExtension: 'md',
    mimeType: 'text/markdown',
    template: `# Threat Intelligence Analysis Report

**Date:** {{timestamp}}
**Analyst:** {{analyst}}
**Classification:** TLP:GREEN

## Executive Summary

This report analyzes {{totalIOCs}} indicators of compromise (IOCs) and generates {{totalQueries}} detection queries across {{vendors}} SIEM platforms.

### Key Findings
- **{{totalTTPs}} MITRE ATT&CK techniques** identified
- **{{highConfidenceIOCs}} high-confidence IOCs** requiring immediate attention
- **{{platforms}} platforms** covered for comprehensive detection

### Threat Landscape
{{threatSummary}}

### Recommended Actions
1. Deploy generated queries to production SIEM environments
2. Monitor for IOC matches and investigate alerts
3. Update threat hunting playbooks with identified TTPs
4. Share indicators with threat intelligence community

---
*Generated by IntelForge Multi-Vendor SIEM Platform*`,
    variables: ['timestamp', 'analyst', 'totalIOCs', 'totalQueries', 'vendors', 'totalTTPs', 'highConfidenceIOCs', 'platforms', 'threatSummary']
  },
  {
    id: 'technical-report',
    name: 'Technical Analysis Report',
    description: 'Detailed technical analysis for SOC analysts',
    fileExtension: 'md',
    mimeType: 'text/markdown',
    template: `# Technical Threat Analysis Report

**Analysis Date:** {{timestamp}}
**Analyst:** {{analyst}}
**Report ID:** {{reportId}}

## Indicators of Compromise (IOCs)

### IP Addresses ({{ipCount}})
{{ipAddresses}}

### Domains ({{domainCount}})
{{domains}}

### File Hashes ({{hashCount}})
{{fileHashes}}

### URLs ({{urlCount}})
{{urls}}

### Email Addresses ({{emailCount}})
{{emailAddresses}}

## MITRE ATT&CK Mapping

{{ttpAnalysis}}

## Detection Queries

{{querySection}}

## Hunting Recommendations

{{huntingRecommendations}}

## IOC Context and Attribution

{{iocContext}}

---
**Confidence Assessment:** {{overallConfidence}}
**Next Review Date:** {{nextReview}}`,
    variables: ['timestamp', 'analyst', 'reportId', 'ipCount', 'ipAddresses', 'domainCount', 'domains', 'hashCount', 'fileHashes', 'urlCount', 'urls', 'emailCount', 'emailAddresses', 'ttpAnalysis', 'querySection', 'huntingRecommendations', 'iocContext', 'overallConfidence', 'nextReview']
  },
  {
    id: 'incident-response',
    name: 'Incident Response Playbook',
    description: 'Actionable playbook for incident response teams',
    fileExtension: 'md',
    mimeType: 'text/markdown',
    template: `# Incident Response Playbook

**Incident ID:** {{incidentId}}
**Created:** {{timestamp}}
**Severity:** {{severity}}
**Analyst:** {{analyst}}

## Immediate Actions Required

### 1. Containment
- [ ] Block malicious IPs at network perimeter
- [ ] Quarantine affected systems
- [ ] Isolate compromised accounts

### 2. Detection Deployment
Deploy the following queries immediately:

{{urgentQueries}}

### 3. Investigation Steps

#### Phase 1: Initial Assessment (0-2 hours)
{{phase1Steps}}

#### Phase 2: Deep Analysis (2-8 hours)
{{phase2Steps}}

#### Phase 3: Remediation (8-24 hours)
{{phase3Steps}}

## IOC Watchlist

### Critical IOCs (Immediate Action)
{{criticalIOCs}}

### Suspicious IOCs (Monitor)
{{suspiciousIOCs}}

## Communication Plan

### Internal Notifications
{{internalNotifications}}

### External Coordination
{{externalCoordination}}

## Recovery Procedures

{{recoverySteps}}

---
**Escalation Contact:** {{escalationContact}}
**Next Update:** {{nextUpdate}}`,
    variables: ['incidentId', 'timestamp', 'severity', 'analyst', 'urgentQueries', 'phase1Steps', 'phase2Steps', 'phase3Steps', 'criticalIOCs', 'suspiciousIOCs', 'internalNotifications', 'externalCoordination', 'recoverySteps', 'escalationContact', 'nextUpdate']
  },
  {
    id: 'stix-bundle',
    name: 'STIX 2.1 Bundle',
    description: 'Structured threat intelligence in STIX format',
    fileExtension: 'json',
    mimeType: 'application/json',
    template: `{
  "type": "bundle",
  "id": "bundle--{{bundleId}}",
  "spec_version": "2.1",
  "objects": [
    {
      "type": "report",
      "id": "report--{{reportId}}",
      "created": "{{timestamp}}",
      "modified": "{{timestamp}}",
      "name": "{{title}}",
      "description": "Threat intelligence analysis with {{totalIOCs}} IOCs and {{totalTTPs}} TTPs",
      "published": "{{timestamp}}",
      "object_refs": [{{objectRefs}}],
      "labels": ["threat-report", "ioc-analysis"]
    }{{indicators}}{{attackPatterns}}
  ]
}`,
    variables: ['bundleId', 'reportId', 'timestamp', 'title', 'totalIOCs', 'totalTTPs', 'objectRefs', 'indicators', 'attackPatterns']
  }
];

export const generateReport = (format: ReportFormat, data: ReportData): string => {
  let content = format.template;
  
  // Basic variable replacements
  content = content.replace(/{{timestamp}}/g, data.timestamp);
  content = content.replace(/{{analyst}}/g, data.analyst);
  content = content.replace(/{{title}}/g, data.title);
  content = content.replace(/{{totalIOCs}}/g, data.summary.totalIOCs.toString());
  content = content.replace(/{{totalQueries}}/g, data.summary.totalQueries.toString());
  content = content.replace(/{{totalTTPs}}/g, data.summary.totalTTPs.toString());
  content = content.replace(/{{vendors}}/g, data.summary.vendors.join(', '));
  
  // IOC-specific replacements
  content = content.replace(/{{ipCount}}/g, (data.iocs.ipv4.length + data.iocs.ipv6.length).toString());
  content = content.replace(/{{domainCount}}/g, data.iocs.domains.length.toString());
  content = content.replace(/{{hashCount}}/g, (data.iocs.sha256.length + data.iocs.md5.length).toString());
  content = content.replace(/{{urlCount}}/g, data.iocs.urls.length.toString());
  content = content.replace(/{{emailCount}}/g, data.iocs.emails.length.toString());
  
  // Generate IOC lists
  if (format.id === 'technical-report') {
    content = content.replace(/{{ipAddresses}}/g, 
      [...data.iocs.ipv4, ...data.iocs.ipv6].map(ip => `- \`${ip}\``).join('\n'));
    content = content.replace(/{{domains}}/g, 
      data.iocs.domains.map(domain => `- \`${domain}\``).join('\n'));
    content = content.replace(/{{fileHashes}}/g, 
      [...data.iocs.sha256, ...data.iocs.md5].map(hash => `- \`${hash}\``).join('\n'));
    content = content.replace(/{{urls}}/g, 
      data.iocs.urls.map(url => `- \`${url}\``).join('\n'));
    content = content.replace(/{{emailAddresses}}/g, 
      data.iocs.emails.map(email => `- \`${email}\``).join('\n'));
  }
  
  // Generate query sections
  if (content.includes('{{querySection}}')) {
    const querySection = data.queries.map((query, index) => {
      const vendor = query.vendor || 'Unknown';
      const language = getQueryLanguage(vendor);
      return `### Query ${index + 1} - ${vendor}\n\n\`\`\`${language}\n${query.query || query}\n\`\`\``;
    }).join('\n\n');
    content = content.replace(/{{querySection}}/g, querySection);
  }
  
  // Generate TTP analysis
  if (content.includes('{{ttpAnalysis}}')) {
    const ttpSection = data.ttps.map(ttp => 
      `### ${ttp.technique_id} - ${ttp.technique_name}\n**Tactic:** ${ttp.tactic}\n**Evidence:** ${ttp.evidence_excerpt}`
    ).join('\n\n');
    content = content.replace(/{{ttpAnalysis}}/g, ttpSection);
  }
  
  // Generate unique IDs for STIX format
  if (format.id === 'stix-bundle') {
    content = content.replace(/{{bundleId}}/g, generateUUID());
    content = content.replace(/{{reportId}}/g, generateUUID());
  }
  
  return content;
};

const getQueryLanguage = (vendor: string): string => {
  switch (vendor) {
    case 'splunk': return 'spl';
    case 'sentinel': return 'kql';
    case 'elastic': return 'esql';
    case 'qradar': return 'aql';
    case 'chronicle': return 'udm';
    default: return 'cql';
  }
};

const generateUUID = (): string => {
  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
    const r = Math.random() * 16 | 0;
    const v = c == 'x' ? r : (r & 0x3 | 0x8);
    return v.toString(16);
  });
};

export const getReportFormatById = (formatId: string): ReportFormat | undefined => {
  return reportFormats.find(format => format.id === formatId);
};
